/**
 * Plane 3: Fabric scaffolding for Tier 1 only.
 * fabric.mod.json, ModMain.java with item and block registries.
 * Optional ExecutionPlan per item → custom item classes (e.g. lightning wand).
 * Items and blocks are added to vanilla creative tabs so they appear in-game.
 */

import type { ExpandedSpecTier1 } from "@themodgenerator/spec";
import type { MaterializedFile } from "./types.js";
import type { ExecutionPlan } from "../execution-plan.js";
import { getItemClassNameForRegistration } from "./behavior-generator.js";

function toClassName(s: string): string {
  return s
    .split(/[-_]/)
    .map((p) => (p ? p[0].toUpperCase() + p.slice(1).toLowerCase() : ""))
    .join("");
}

function escapeJson(s: string): string {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

function escapeJava(s: string): string {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function buildGradle(modId: string): string {
  return `plugins {
	id 'java'
	id 'fabric-loom' version '1.7-SNAPSHOT'
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

repositories {
	mavenCentral()
	maven { url = "https://maven.fabricmc.net/" }
}

loom {
	splitEnvironmentSourceSets()
	mods {
		"${modId}" {
			sourceSet("main")
		}
	}
}

dependencies {
	minecraft "com.mojang:minecraft:\${project.minecraft_version}"
	mappings "net.fabricmc:yarn:\${project.yarn_mappings}:v2"
	modImplementation "net.fabricmc:fabric-loader:\${project.loader_version}"
	modImplementation "net.fabricmc.fabric-api:fabric-api:\${project.fabric_version}"
}

processResources {
	inputs.property "version", project.version
	filteringCharset "UTF-8"
	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
	withSourcesJar()
}
`;
}

function gradleProperties(): string {
  return `# Fabric 1.21.1
minecraft_version=1.21.1
yarn_mappings=1.21.1+build.3
loader_version=0.16.9
fabric_version=0.109.0+1.21.1

mod_version=1.0.0
maven_group=net.themodgenerator
archives_base_name=generated

# Cloud Run jobs: no daemon, foreground-only, constrained JVM
org.gradle.daemon=false
org.gradle.jvmargs=-Xms256m -Xmx1g -XX:MaxMetaspaceSize=512m
org.gradle.parallel=false
org.gradle.workers.max=1
`;
}

function settingsGradle(modId: string): string {
  return `pluginManagement {
	repositories {
		maven { url = "https://maven.fabricmc.net/" }
		gradlePluginPortal()
	}
}

rootProject.name = "${modId}"
`;
}

function fabricModJson(modId: string, modName: string, javaPackage: string, className: string): string {
  return `{
  "schemaVersion": 1,
  "id": "${modId}",
  "version": "\${version}",
  "name": "${escapeJson(modName)}",
  "description": "Generated by The Mod Generator",
  "environment": "*",
  "entrypoints": {
    "main": [
      "net.themodgenerator.${javaPackage}.${className}"
    ]
  },
  "depends": {
    "fabricloader": ">=0.16.0",
    "minecraft": "~1.21.1",
    "java": ">=21",
    "fabric-api": "*"
  }
}
`;
}

function toJavaId(id: string): string {
  return id.replace(/-/g, "_");
}

/** Wood family block id suffixes (must match expand-wood-type). */
const WOOD_BLOCK_SUFFIXES = [
  "_log", "_stripped_log", "_wood", "_stripped_wood", "_planks",
  "_stairs", "_slab", "_fence", "_fence_gate", "_door", "_trapdoor", "_pressure_plate", "_button", "_sign", "_hanging_sign",
];

/** Log/wood blocks only (must be PillarBlock for StrippableBlockRegistry AXIS requirement). */
const LOG_OR_WOOD_SUFFIXES = ["_log", "_stripped_log", "_wood", "_stripped_wood"] as const;

function isWoodBlock(blockId: string, woodIds: string[]): boolean {
  return woodIds.some((w) => WOOD_BLOCK_SUFFIXES.some((s) => blockId === w + s));
}

function isLogOrWoodBlock(blockId: string, woodIds: string[]): boolean {
  return woodIds.some((w) => LOG_OR_WOOD_SUFFIXES.some((s) => blockId === w + s));
}

/**
 * AbstractBlock.Settings for wood blocks: vanilla-equivalent (hardness, resistance, sounds, burnable).
 * Loot table resolved by block registry ID (data/<modId>/loot_tables/blocks/<block_id>.json).
 * Never calls dropsNothing or noDrops.
 */
function woodBlockSettings(): string {
  return "AbstractBlock.Settings.create().strength(2.0f, 3.0f).sounds(BlockSoundGroup.WOOD).burnable()";
}

/** Generate Java that adds registered items to the INGREDIENTS creative tab so they appear in-game. */
function creativeTabItems(itemIds: string[]): string {
  if (itemIds.length === 0) return "";
  const addLines = itemIds
    .map((id) => `			entries.add(Registries.ITEM.get(Identifier.of(MOD_ID, "${id}")));`)
    .join("\n");
  return `		ItemGroupEvents.modifyEntriesEvent(ItemGroups.INGREDIENTS).register(entries -> {\n${addLines}\n		});`;
}

/** Generate Java that adds registered block items to the BUILDING_BLOCKS creative tab. */
function creativeTabBlocks(blockIds: string[]): string {
  if (blockIds.length === 0) return "";
  const addLines = blockIds
    .map((id) => `			entries.add(Registries.ITEM.get(Identifier.of(MOD_ID, "${id}")));`)
    .join("\n");
  return `		ItemGroupEvents.modifyEntriesEvent(ItemGroups.BUILDING_BLOCKS).register(entries -> {\n${addLines}\n		});`;
}

function modMainJava(
  modId: string,
  modName: string,
  javaPackage: string,
  className: string,
  expanded: ExpandedSpecTier1,
  itemPlans?: ExecutionPlan[]
): string {
  const itemRegistrations = expanded.items
    .map((item, i) => {
      const plan = itemPlans?.[i];
      const itemClassName = getItemClassNameForRegistration(item.id, plan);
      return `		Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "${item.id}"), new ${itemClassName}(new Item.Settings()));`;
    })
    .join("\n");
  const woodIds = (expanded.spec.woodTypes ?? []).map((w) => w.id);
  const blockLines: string[] = [];
  for (const block of expanded.blocks) {
    const varName = toJavaId(block.id) + "Block";
    const useWoodSettings = woodIds.length > 0 && isWoodBlock(block.id, woodIds);
    const settings = useWoodSettings ? woodBlockSettings() : "AbstractBlock.Settings.create()";
    const usePillarBlock = woodIds.length > 0 && isLogOrWoodBlock(block.id, woodIds);
    const blockCtor = usePillarBlock ? "PillarBlock" : "Block";
    blockLines.push(`		Block ${varName} = Registry.register(Registries.BLOCK, Identifier.of(MOD_ID, "${block.id}"), new ${blockCtor}(${settings}));`);
    blockLines.push(`		Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "${block.id}"), new BlockItem(${varName}, new Item.Settings()));`);
  }
  const blockRegistrations = blockLines.join("\n");

  const strippingLines: string[] = [];
  if (woodIds.length > 0) {
    strippingLines.push("		// Only register log/wood (blocks with AXIS); skip if missing to avoid StrippableBlockRegistry crash");
    for (const woodId of woodIds) {
      const logVar = toJavaId(woodId + "_log") + "Block";
      const strippedLogVar = toJavaId(woodId + "_stripped_log") + "Block";
      const woodVar = toJavaId(woodId + "_wood") + "Block";
      const strippedWoodVar = toJavaId(woodId + "_stripped_wood") + "Block";
      strippingLines.push(`		registerStrippableIfHasAxis(${logVar}, ${strippedLogVar});`);
      strippingLines.push(`		registerStrippableIfHasAxis(${woodVar}, ${strippedWoodVar});`);
    }
  }
  const strippingRegistration = strippingLines.length > 0 ? strippingLines.join("\n") : "";
  const needsStrippableHelper = strippingLines.length > 0;

  const hasItems = expanded.items.length > 0;
  const hasBlocks = expanded.blocks.length > 0;
  const imports: string[] = [
    "package net.themodgenerator." + javaPackage + ";",
    "",
    "import net.fabricmc.api.ModInitializer;",
    "import net.fabricmc.fabric.api.itemgroup.v1.ItemGroupEvents;",
    "import net.fabricmc.fabric.api.registry.StrippableBlockRegistry;",
    "import net.minecraft.block.AbstractBlock;",
    "import net.minecraft.block.Block;",
    "import net.minecraft.block.PillarBlock;",
    "import net.minecraft.state.property.Properties;",
    "import net.minecraft.sound.BlockSoundGroup;",
    "import net.minecraft.item.BlockItem;",
    "import net.minecraft.item.Item;",
    "import net.minecraft.item.ItemGroups;",
    "import net.minecraft.registry.Registries;",
    "import net.minecraft.registry.Registry;",
    "import net.minecraft.util.Identifier;",
    "import org.slf4j.Logger;",
    "import org.slf4j.LoggerFactory;",
    "",
  ];
  const initBody: string[] = [];
  if (hasItems) initBody.push(itemRegistrations);
  if (hasBlocks) initBody.push(blockRegistrations);
  if (strippingRegistration) initBody.push(strippingRegistration);
  if (hasItems) {
    initBody.push(creativeTabItems(expanded.items.map((i) => i.id)));
  }
  if (hasBlocks) {
    initBody.push(creativeTabBlocks(expanded.blocks.map((b) => b.id)));
  }
  initBody.push("		LOGGER.info(\"" + escapeJava(modName) + " initialized.\");");

  const strippableHelper =
    needsStrippableHelper
      ? [
          "",
          "	/** Only register if both blocks have AXIS (PillarBlock); avoids StrippableBlockRegistry IllegalArgumentException. */",
          "	private static void registerStrippableIfHasAxis(Block input, Block stripped) {",
          "		if (input.getDefaultState().contains(Properties.AXIS) && stripped.getDefaultState().contains(Properties.AXIS)) {",
          "			StrippableBlockRegistry.register(input, stripped);",
          "		}",
          "	}",
        ]
      : [];

  const body = [
    "public class " + className + " implements ModInitializer {",
    "	public static final String MOD_ID = \"" + modId + "\";",
    "	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);",
    "",
    "	@Override",
    "	public void onInitialize() {",
    ...initBody,
    "	}",
    ...strippableHelper,
    "}",
  ];

  return imports.join("\n") + "\n" + body.join("\n") + "\n";
}

function mixinsJson(modId: string): string {
  return `{
  "required": true,
  "package": "net.themodgenerator.${modId.replace(/-/g, "_")}.mixin",
  "compatibilityLevel": "JAVA_21",
  "mixins": [],
  "injectors": {
    "defaultRequire": 1
  }
}
`;
}

export interface FabricScaffoldOptions {
  /** When provided, custom item classes (e.g. lightning wand) are registered per plan. */
  itemPlans?: ExecutionPlan[];
}

/**
 * Generate Fabric scaffolding files (build, fabric.mod.json, ModMain, mixins).
 * Deterministic; same expanded + options → same output.
 * When itemPlans[i] requires custom behavior, ModMain registers that custom class.
 */
export function fabricScaffoldFiles(
  expanded: ExpandedSpecTier1,
  options?: FabricScaffoldOptions
): MaterializedFile[] {
  const modId = expanded.spec.modId;
  const modName = expanded.spec.modName;
  const javaPackage = modId.replace(/-/g, "_");
  const className = toClassName(modId) + "Mod";
  const itemPlans = options?.itemPlans;

  const files: MaterializedFile[] = [
    { path: "build.gradle", contents: buildGradle(modId) },
    { path: "gradle.properties", contents: gradleProperties() },
    { path: "settings.gradle", contents: settingsGradle(modId) },
    {
      path: "src/main/resources/fabric.mod.json",
      contents: fabricModJson(modId, modName, javaPackage, className),
    },
    {
      path: `src/main/java/net/themodgenerator/${javaPackage}/${className}.java`,
      contents: modMainJava(modId, modName, javaPackage, className, expanded, itemPlans),
    },
    {
      path: `src/main/resources/${modId}.mixins.json`,
      contents: mixinsJson(modId),
    },
  ];
  return files.sort((a, b) => a.path.localeCompare(b.path));
}
