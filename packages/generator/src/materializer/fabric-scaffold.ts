/**
 * Plane 3: Fabric scaffolding for Tier 1 only.
 * fabric.mod.json, ModMain.java with item and block registries.
 * Optional ExecutionPlan per item → custom item classes (e.g. lightning wand).
 * Items and blocks are added to vanilla creative tabs so they appear in-game.
 */

import type { ExpandedSpecTier1 } from "@themodgenerator/spec";
import type { MaterializedFile } from "./types.js";
import type { ExecutionPlan } from "../execution-plan.js";
import { getItemClassNameForRegistration } from "./behavior-generator.js";
import {
  woodBlockRegistrationJava,
  hangingSignBlockIds,
  getWoodBlockSpec,
} from "./vanilla-wood-family.js";

function toClassName(s: string): string {
  return s
    .split(/[-_]/)
    .map((p) => (p ? p[0].toUpperCase() + p.slice(1).toLowerCase() : ""))
    .join("");
}

function escapeJson(s: string): string {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

function escapeJava(s: string): string {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function buildGradle(modId: string, hasClientSources: boolean): string {
  const modSourceSets = hasClientSources
    ? 'sourceSet("main")\n\t\t\tsourceSet("client")'
    : 'sourceSet("main")';
  return `plugins {
	id 'java'
	id 'fabric-loom' version '1.7-SNAPSHOT'
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

repositories {
	mavenCentral()
	maven { url = "https://maven.fabricmc.net/" }
}

loom {
	splitEnvironmentSourceSets()
	mods {
		"${modId}" {
			${modSourceSets}
		}
	}
}

dependencies {
	minecraft "com.mojang:minecraft:\${project.minecraft_version}"
	mappings "net.fabricmc:yarn:\${project.yarn_mappings}:v2"
	modImplementation "net.fabricmc:fabric-loader:\${project.loader_version}"
	modImplementation "net.fabricmc.fabric-api:fabric-api:\${project.fabric_version}"
}

processResources {
	inputs.property "version", project.version
	filteringCharset "UTF-8"
	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
	withSourcesJar()
}
`;
}

function gradleProperties(): string {
  return `# Fabric 1.21.1
minecraft_version=1.21.1
yarn_mappings=1.21.1+build.3
loader_version=0.16.9
fabric_version=0.109.0+1.21.1

mod_version=1.0.0
maven_group=net.themodgenerator
archives_base_name=generated

# Cloud Run jobs: no daemon, foreground-only, constrained JVM
org.gradle.daemon=false
org.gradle.jvmargs=-Xms256m -Xmx1g -XX:MaxMetaspaceSize=512m
org.gradle.parallel=false
org.gradle.workers.max=1
`;
}

function settingsGradle(modId: string): string {
  return `pluginManagement {
	repositories {
		maven { url = "https://maven.fabricmc.net/" }
		gradlePluginPortal()
	}
}

rootProject.name = "${modId}"
`;
}

function fabricModJson(
  modId: string,
  modName: string,
  javaPackage: string,
  className: string,
  hasHangingSigns: boolean
): string {
  const clientEntrypoint = hasHangingSigns
    ? `,
    "client": [
      "net.themodgenerator.${javaPackage}.${className}Client"
    ]`
    : "";
  return `{
  "schemaVersion": 1,
  "id": "${modId}",
  "version": "\${version}",
  "name": "${escapeJson(modName)}",
  "description": "Generated by The Mod Generator",
  "environment": "*",
  "entrypoints": {
    "main": [
      "net.themodgenerator.${javaPackage}.${className}"
    ]${clientEntrypoint}
  },
  "depends": {
    "fabricloader": ">=0.16.0",
    "minecraft": "~1.21.1",
    "java": ">=21",
    "fabric-api": "*"
  }
}
`;
}

function toJavaId(id: string): string {
  return id.replace(/-/g, "_");
}

/**
 * AbstractBlock.Settings for non-wood blocks. Wood blocks use vanilla-wood-family (Settings.copy(vanilla)).
 */
function defaultBlockSettings(): string {
  return "AbstractBlock.Settings.create()";
}

/** Generate Java that adds registered items to the INGREDIENTS creative tab so they appear in-game. */
function creativeTabItems(itemIds: string[]): string {
  if (itemIds.length === 0) return "";
  const addLines = itemIds
    .map((id) => `			entries.add(Registries.ITEM.get(Identifier.of(MOD_ID, "${id}")));`)
    .join("\n");
  return `		ItemGroupEvents.modifyEntriesEvent(ItemGroups.INGREDIENTS).register(entries -> {\n${addLines}\n		});`;
}

/** Generate Java that adds registered block items to the BUILDING_BLOCKS creative tab. */
function creativeTabBlocks(blockIds: string[]): string {
  if (blockIds.length === 0) return "";
  const addLines = blockIds
    .map((id) => `			entries.add(Registries.ITEM.get(Identifier.of(MOD_ID, "${id}")));`)
    .join("\n");
  return `		ItemGroupEvents.modifyEntriesEvent(ItemGroups.BUILDING_BLOCKS).register(entries -> {\n${addLines}\n		});`;
}

function modMainJava(
  modId: string,
  modName: string,
  javaPackage: string,
  className: string,
  expanded: ExpandedSpecTier1,
  itemPlans?: ExecutionPlan[],
  buildStamp?: string
): string {
  const woodIds = (expanded.spec.woodTypes ?? []).map((w) => w.id);
  const hangingSignIds = hangingSignBlockIds(expanded);
  const hasHangingSigns = hangingSignIds.length > 0;
  const hangingSignItemIds = new Set(woodIds.map((w) => w + "_hanging_sign"));
  const itemRegistrations = expanded.items
    .filter((item) => !(hasHangingSigns && hangingSignItemIds.has(item.id)))
    .map((item, i) => {
      const plan = itemPlans?.[i];
      const itemClassName = getItemClassNameForRegistration(item.id, plan);
      return `		Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "${item.id}"), new ${itemClassName}(new Item.Settings()));`;
    })
    .join("\n");
  const blockLines: string[] = [];
  if (hasHangingSigns) {
    blockLines.push("		// Create hanging sign blocks first (needed for BlockEntityType registration)");
    for (const blockId of hangingSignIds) {
      const varName = toJavaId(blockId) + "Block";
      const spec = getWoodBlockSpec(blockId, woodIds);
      const settings = spec ? `AbstractBlock.Settings.copy(${spec.vanillaBlock})` : "AbstractBlock.Settings.create()";
      const isWall = blockId.endsWith("_wall_hanging_sign");
      const blockClass = isWall ? "ModWallHangingSignBlock" : "ModHangingSignBlock";
      blockLines.push(`		${blockClass} ${varName} = new ${blockClass}(WoodType.OAK, ${settings});`);
    }
    const hangingSignVars = hangingSignIds.map((id) => toJavaId(id) + "Block").join(", ");
    blockLines.push("		// Register BlockEntityType for hanging signs (vanilla type doesn't include mod blocks)");
    blockLines.push(`		HANGING_SIGN_BLOCK_ENTITY = Registry.register(Registries.BLOCK_ENTITY_TYPE, Identifier.of(MOD_ID, "hanging_sign_block_entity"), FabricBlockEntityTypeBuilder.create(ModHangingSignBlockEntity::new, ${hangingSignVars}).build());`);
    blockLines.push("");
  }
  for (const block of expanded.blocks) {
    const varName = toJavaId(block.id) + "Block";
    const isHangingSign = hangingSignIds.includes(block.id);
    if (isHangingSign) {
      blockLines.push(`		Registry.register(Registries.BLOCK, Identifier.of(MOD_ID, "${block.id}"), ${varName});`);
      const isCeiling = block.id.endsWith("_hanging_sign") && !block.id.endsWith("_wall_hanging_sign");
      if (isCeiling) {
        const wallId = block.id.replace(/_hanging_sign$/, "_wall_hanging_sign");
        const wallVar = toJavaId(wallId) + "Block";
        blockLines.push(`		Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "${block.id}"), new HangingSignItem(${varName}, ${wallVar}, new Item.Settings()));`);
      } else {
        blockLines.push(`		Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "${block.id}"), new BlockItem(${varName}, new Item.Settings()));`);
      }
    } else {
      const woodReg = woodIds.length > 0 ? woodBlockRegistrationJava(block.id, woodIds) : null;
      if (woodReg) {
        blockLines.push(`		${woodReg.line}`);
      } else {
        const settings = defaultBlockSettings();
        blockLines.push(`		Block ${varName} = Registry.register(Registries.BLOCK, Identifier.of(MOD_ID, "${block.id}"), new Block(${settings}));`);
      }
      blockLines.push(`		Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "${block.id}"), new BlockItem(${varName}, new Item.Settings()));`);
    }
  }
  const blockRegistrations = blockLines.join("\n");

  const strippingLines: string[] = [];
  if (woodIds.length > 0) {
    strippingLines.push("		// Only register log/wood (blocks with AXIS); skip if missing to avoid StrippableBlockRegistry crash");
    for (const woodId of woodIds) {
      const logVar = toJavaId(woodId + "_log") + "Block";
      const strippedLogVar = toJavaId(woodId + "_stripped_log") + "Block";
      const woodVar = toJavaId(woodId + "_wood") + "Block";
      const strippedWoodVar = toJavaId(woodId + "_stripped_wood") + "Block";
      strippingLines.push(`		registerStrippableIfHasAxis(${logVar}, ${strippedLogVar});`);
      strippingLines.push(`		registerStrippableIfHasAxis(${woodVar}, ${strippedWoodVar});`);
    }
  }
  const strippingRegistration = strippingLines.length > 0 ? strippingLines.join("\n") : "";
  const needsStrippableHelper = strippingLines.length > 0;

  const hasItems = expanded.items.length > 0;
  const hasBlocks = expanded.blocks.length > 0;
  const imports: string[] = [
    "package net.themodgenerator." + javaPackage + ";",
    "",
    "import net.fabricmc.api.ModInitializer;",
    "import net.fabricmc.fabric.api.itemgroup.v1.ItemGroupEvents;",
    "import net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;",
    "import net.fabricmc.fabric.api.registry.StrippableBlockRegistry;",
    "import net.minecraft.block.AbstractBlock;",
    "import net.minecraft.block.Block;",
    "import net.minecraft.block.BlockSetType;",
    "import net.minecraft.block.ButtonBlock;",
    "import net.minecraft.block.DoorBlock;",
    "import net.minecraft.block.FenceBlock;",
    "import net.minecraft.block.FenceGateBlock;",
    "import net.minecraft.block.HangingSignBlock;",
    "import net.minecraft.block.WallHangingSignBlock;",
    "import net.minecraft.block.PillarBlock;",
    "import net.minecraft.block.PressurePlateBlock;",
    "import net.minecraft.block.SlabBlock;",
    "import net.minecraft.block.StairsBlock;",
    "import net.minecraft.block.TrapdoorBlock;",
    "import net.minecraft.block.WoodType;",
    "import net.minecraft.block.Blocks;",
    "import net.minecraft.block.entity.BlockEntityType;",
    "import net.minecraft.state.property.Properties;",
    "import net.minecraft.item.BlockItem;",
    "import net.minecraft.item.HangingSignItem;",
    "import net.minecraft.item.Item;",
    "import net.minecraft.item.ItemGroups;",
    "import net.minecraft.registry.Registries;",
    "import net.minecraft.registry.Registry;",
    "import net.minecraft.util.Identifier;",
    "import org.slf4j.Logger;",
    "import org.slf4j.LoggerFactory;",
    "",
  ];
  const initBody: string[] = [];
  if (hasItems) initBody.push(itemRegistrations);
  if (hasBlocks) initBody.push(blockRegistrations);
  if (strippingRegistration) initBody.push(strippingRegistration);
  if (hasItems) {
    initBody.push(creativeTabItems(expanded.items.map((i) => i.id)));
  }
  if (hasBlocks) {
    initBody.push(creativeTabBlocks(expanded.blocks.map((b) => b.id)));
  }
  if (buildStamp) {
    initBody.push('		LOGGER.info("GENERATED MOD BUILD STAMP: " + "' + escapeJava(buildStamp) + '");');
  }
  initBody.push("		LOGGER.info(\"" + escapeJava(modName) + " initialized.\");");

  const strippableHelper =
    needsStrippableHelper
      ? [
          "",
          "	/** Only register if both blocks have AXIS (PillarBlock); avoids StrippableBlockRegistry IllegalArgumentException. */",
          "	private static void registerStrippableIfHasAxis(Block input, Block stripped) {",
          "		if (input.getDefaultState().contains(Properties.AXIS) && stripped.getDefaultState().contains(Properties.AXIS)) {",
          "			StrippableBlockRegistry.register(input, stripped);",
          "		}",
          "	}",
        ]
      : [];

  const hangingSignField =
    hasHangingSigns
      ? [
          "	public static BlockEntityType<ModHangingSignBlockEntity> HANGING_SIGN_BLOCK_ENTITY;",
          "",
        ]
      : [];

  const body = [
    "public class " + className + " implements ModInitializer {",
    "	public static final String MOD_ID = \"" + modId + "\";",
    "	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);",
    ...hangingSignField,
    "	@Override",
    "	public void onInitialize() {",
    ...initBody,
    "	}",
    ...strippableHelper,
    "}",
  ];

  return imports.join("\n") + "\n" + body.join("\n") + "\n";
}

function modHangingSignBlockEntityJava(javaPackage: string, mainClassName: string): string {
  return `package net.themodgenerator.${javaPackage};

import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.block.entity.SignBlockEntity;
import net.minecraft.sound.SoundEvent;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.math.BlockPos;

/** Block entity for mod hanging signs; uses mod BlockEntityType so placement does not crash.
 * Extends SignBlockEntity (not HangingSignBlockEntity) because HangingSignBlockEntity only has
 * (BlockPos, BlockState) ctor and cannot take a custom BlockEntityType in 1.21.1. */
public class ModHangingSignBlockEntity extends SignBlockEntity {
	public ModHangingSignBlockEntity(BlockPos pos, BlockState state) {
		super(${mainClassName}.HANGING_SIGN_BLOCK_ENTITY, pos, state);
	}

	@Override
	public int getTextLineHeight() {
		return 10;
	}

	@Override
	public int getMaxTextWidth() {
		return 60;
	}

	@Override
	public SoundEvent getInteractionFailSound() {
		return SoundEvents.BLOCK_HANGING_SIGN_HIT;
	}
}
`;
}

function modHangingSignBlockJava(javaPackage: string): string {
  return `package net.themodgenerator.${javaPackage};

import net.minecraft.block.AbstractBlock;
import net.minecraft.block.BlockState;
import net.minecraft.block.HangingSignBlock;
import net.minecraft.block.WoodType;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.util.math.BlockPos;
import org.jetbrains.annotations.Nullable;

/** Hanging sign block (ceiling) that creates ModHangingSignBlockEntity; vanilla BlockEntityType doesn't include mod blocks. */
public class ModHangingSignBlock extends HangingSignBlock {
	public ModHangingSignBlock(WoodType woodType, AbstractBlock.Settings settings) {
		super(woodType, settings);
	}

	@Nullable
	@Override
	public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
		return new ModHangingSignBlockEntity(pos, state);
	}
}
`;
}

function modWallHangingSignBlockJava(javaPackage: string): string {
  return `package net.themodgenerator.${javaPackage};

import net.minecraft.block.AbstractBlock;
import net.minecraft.block.BlockState;
import net.minecraft.block.WallHangingSignBlock;
import net.minecraft.block.WoodType;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.util.math.BlockPos;
import org.jetbrains.annotations.Nullable;

/** Wall hanging sign block that creates ModHangingSignBlockEntity; vanilla BlockEntityType doesn't include mod blocks. */
public class ModWallHangingSignBlock extends WallHangingSignBlock {
	public ModWallHangingSignBlock(WoodType woodType, AbstractBlock.Settings settings) {
		super(woodType, settings);
	}

	@Nullable
	@Override
	public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
		return new ModHangingSignBlockEntity(pos, state);
	}
}
`;
}

function modClientJava(javaPackage: string, mainClassName: string): string {
  return `package net.themodgenerator.${javaPackage};

import net.fabricmc.api.ClientModInitializer;
import net.minecraft.client.render.block.entity.BlockEntityRendererFactories;
import net.minecraft.client.render.block.entity.HangingSignBlockEntityRenderer;

/** Client-side: register block entity renderer for mod hanging signs. */
public class ${mainClassName}Client implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		BlockEntityRendererFactories.register(${mainClassName}.HANGING_SIGN_BLOCK_ENTITY, HangingSignBlockEntityRenderer::new);
	}
}
`;
}

function mixinsJson(modId: string): string {
  const javaPackage = modId.replace(/-/g, "_");
  return `{
  "required": true,
  "package": "net.themodgenerator.${javaPackage}.mixin",
  "compatibilityLevel": "JAVA_21",
  "mixins": [],
  "client": [],
  "injectors": {
    "defaultRequire": 1
  }
}
`;
}

export interface FabricScaffoldOptions {
  /** When provided, custom item classes (e.g. lightning wand) are registered per plan. */
  itemPlans?: ExecutionPlan[];
  /** Build stamp logged at mod init for jar verification (e.g. git sha + timestamp). */
  buildStamp?: string;
}

/**
 * Generate Fabric scaffolding files (build, fabric.mod.json, ModMain, mixins).
 * Deterministic; same expanded + options → same output.
 * When itemPlans[i] requires custom behavior, ModMain registers that custom class.
 */
export function fabricScaffoldFiles(
  expanded: ExpandedSpecTier1,
  options?: FabricScaffoldOptions
): MaterializedFile[] {
  const modId = expanded.spec.modId;
  const modName = expanded.spec.modName;
  const javaPackage = modId.replace(/-/g, "_");
  const className = toClassName(modId) + "Mod";
  const itemPlans = options?.itemPlans;
  const buildStamp = options?.buildStamp;

  const hasHangingSigns = hangingSignBlockIds(expanded).length > 0;
  const hasClientSources = hasHangingSigns;
  const files: MaterializedFile[] = [
    { path: "build.gradle", contents: buildGradle(modId, hasClientSources) },
    { path: "gradle.properties", contents: gradleProperties() },
    { path: "settings.gradle", contents: settingsGradle(modId) },
    {
      path: "src/main/resources/fabric.mod.json",
      contents: fabricModJson(modId, modName, javaPackage, className, hasHangingSigns),
    },
    {
      path: `src/main/java/net/themodgenerator/${javaPackage}/${className}.java`,
      contents: modMainJava(modId, modName, javaPackage, className, expanded, itemPlans, buildStamp),
    },
    {
      path: `src/main/resources/${modId}.mixins.json`,
      contents: mixinsJson(modId),
    },
  ];
  if (hasHangingSigns) {
    files.push({
      path: `src/main/java/net/themodgenerator/${javaPackage}/ModHangingSignBlockEntity.java`,
      contents: modHangingSignBlockEntityJava(javaPackage, className),
    });
    files.push({
      path: `src/main/java/net/themodgenerator/${javaPackage}/ModHangingSignBlock.java`,
      contents: modHangingSignBlockJava(javaPackage),
    });
    files.push({
      path: `src/main/java/net/themodgenerator/${javaPackage}/ModWallHangingSignBlock.java`,
      contents: modWallHangingSignBlockJava(javaPackage),
    });
    files.push({
      path: `src/client/java/net/themodgenerator/${javaPackage}/${className}Client.java`,
      contents: modClientJava(javaPackage, className),
    });
  }
  return files.sort((a, b) => a.path.localeCompare(b.path));
}
